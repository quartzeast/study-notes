/*
    指针是可计算的

    1+1=2?
        • 给⼀个指针加 1 表⽰要让指针指向下⼀个变量
            int a[10];
            int *p = a;
            *(p+1) —> a[1]
        • 如果指针不是指向⼀⽚连续分配的空间，则这种运算没有意义

    指针计算
        • 这些算术运算可以对指针做：
        • 给指针加、减⼀个整数(+, +=, -, -=)
        • 递增递减(++/—)
        • 两个指针相减

    *p++
        • 取出p所指的那个数据，完事之后顺便把p移到下⼀个位置去
        • *的优先级虽然⾼，但是没有++⾼
        • 常⽤于数组类的连续空间操作
        • 在某些CPU上，这可以直接被翻译成⼀条汇编指令

    指针⽐较
        • <, <=, ==, >, >=, != 都可以对指针做
        • ⽐较它们在内存中的地址
        • 数组中的单元的地址肯定是线性递增的

    0地址
        • 当然你的内存中有0地址，但是0地址通常是个不能随便碰的地址
        • 所以你的指针不应该具有0值
        • 因此可以⽤0地址来表⽰特殊的事情：
            • 返回的指针是⽆效的
            • 指针没有被真正初始化（先初始化为0）
            • NULL是⼀个预定定义的符号，表⽰0地址
        • 有的编译器不愿意你⽤0来表⽰0地址

    指针的类型
        • ⽆论指向什么类型，所有的指针的⼤⼩都是⼀样的，因为都是地址
        • 但是指向不同类型的指针是不能直接互相赋值的
        • 这是为了避免⽤错指针

    指针的类型转换
        • void* 表⽰不知道指向什么东⻄西的指针
            • 计算时与char*相同（但不相通）
        • 指针也可以转换类型
            • int *p = &i; void* q = (void*)p;
        • 这并没有改变p所指的变量的类型，⽽是让后⼈⽤不同的眼光通过p看它所指的变量
            • 我不再当你是int啦，我认为你就是个void!

    ⽤指针来做什么
        • 需要传⼊较⼤的数据时⽤作参数
        • 传⼊数组后对数组做操作
        • 函数返回不⽌⼀个结果
            • 需要⽤函数来修改不⽌⼀个变量
        • 动态申请的内存...
*/
#include <stdio.h>

void iterateArray(void);

// *p -> ac[0]
// *(p+1) -> ac[1]
// *(p+n) <-> ac[n]
int main(void)
{
    char ac[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    char *p = ac;
    char *p1 = &ac[5];
    printf("p  =%p\n", p);
    printf("p+1=%p\n", p + 1);
    printf("*(p+1)=%d\n", *(p + 1));
    printf("p1-p=%d\n", p1 - p);

    int ai[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    int *q = ai;
    int *q1 = &ai[6];
    printf("q  =%p\n", q);
    printf("q+1=%p\n", q + 1);
    printf("*(q+1)=%d\n", *(q + 1));
    printf("q1-q=%d\n", q1 - q);

    iterateArray();
    return 0;
}

void iterateArray(void)
{
    char ac[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1 };
    char *p = &ac[0];
    int i;
    for (i = 0; i < sizeof(ac) / sizeof(ac[0]); i++) {
        printf("%d\n", ac[i]);
    }

    // for (p = ac; *p != -1; p++) {
    while (*p != -1) {
        printf("%d\n", *p++);
    }
}